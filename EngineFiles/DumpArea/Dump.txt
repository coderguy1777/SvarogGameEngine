#include "GameEngineHeader.h"
#include "EngineCamera.h"
using namespace std;

class SvarogEngineCamera {
    public:
        double dx = 0.0;
        double dy = 0.0;
        double dz = 0.0;
        double speedval = 5.0;
        vector<double>camerapos;
        vector<double>camerarotation;
        vector<cameradimensions>camera1;

    void initialcamera() {
        int CAMERAHEIGHT;
        int CAMERAWIDTH;
        cout << "What would you like the camera height to be?" << endl;
        int heightvalue;
        cin >> heightvalue;
        cout << "What would you like the camera width to be?" << endl;
        int widthvalue; 
        cin >> widthvalue;
        double i, j, k = 0.0;
        camerapos.push_back(i);
        camerapos.push_back(j);
        camerapos.push_back(k);
        camera1.push_back({CAMERAHEIGHT, CAMERAWIDTH});

    }

    void cameradirection() {
        double cameraposx = 0.0;
        double cameraposy = 0.0;
        double cameraposz = 0.0;
        char directioninput = getchar();

        if(directioninput == 32) {
            cameraposz += dz + speedval;
            cameraposy += dy;
            cameraposx += dx;
            camerapos.push_back(cameraposx);
            camerapos.push_back(cameraposy);
            camerapos.push_back(cameraposz);
        }

        else if(directioninput == 32 && directioninput == 68) {
            cameraposz += dz + speedval;
            cameraposy += dy + speedval;
            cameraposx += dx;
            for(unsigned int i = 0; i < camerapos.size(); i++) {
                camerapos.pop_back();
            }
            camerapos.push_back(cameraposx);
            camerapos.push_back(cameraposy);
            camerapos.push_back(cameraposz);
        }
    }

    double camerarot(int axis, double var1, double var2, double var3) {
        double x = var1;
        double y = var2;
        double z = var3;

        double rotx1, rotx2, rotx3;
        double roty1, roty2, roty3;
        double rotz1, rotz2, rotz3;

        vector<veccoordinates>primesofxyz;
        if(axis == 1) {
            rotx1 = 1;
            rotx2 = 0;
            rotx3 = 0;
            roty1 = cos(y);
            roty2 = -sin(y);
            roty3 = 0;
            rotz1 = sin(z);
            rotz2 = cos(z);
            rotz3 = 0;
            double inversemat[3][3];
            primesofxyz.push_back({rotx1, rotx2, rotx3});
            primesofxyz.push_back({roty1, roty2, roty3});
            primesofxyz.push_back({rotz1, rotz2, rotz3});
            for(unsigned int i = 0; i < primesofxyz.size(); i++) {
                inversemat[i][0] = primesofxyz[i].x;
                inversemat[i][1] = primesofxyz[i].y;
                inversemat[i][2] = primesofxyz[i].z;
                cout << primesofxyz[i].x << endl;
                cout << primesofxyz[i].y << endl;
                cout << primesofxyz[i].z << endl;


            }
        }

        if(axis == 2) {


        }

        if(axis == 3) {

            
        }
        return var1;
    }

    double inverseproductsofmatrix(double a, double b, double c) {
        return a;
    }

};

void changeSize(int w, int h) {

	// Prevent a divide by zero, when window is too short
	// (you cant make a window of zero width).
	if (h == 0)
		h = 1;

	float ratio =  w * 1.0 / h;

	// Use the Projection Matrix
	glMatrixMode(GL_PROJECTION);

	// Reset Matrix
	glLoadIdentity();

	// Set the viewport to be the entire window
	glViewport(0, 0, w, h);

	// Set the correct perspective.
	gluPerspective(45.0f, ratio, 0.1f, 100.0f);

	// Get Back to the Modelview
	glMatrixMode(GL_MODELVIEW);
}


void processNormalKeys(unsigned char key, int x, int y) {
	int mod;
	cout << lx << endl;
	cout << lz << endl;
	if (key == 27) {
		exit(0);
	}
    if(key == 'f') {
		lx += lx + 5;
	}

	if(key == 'w') {
		lz -= lz * 5;
	}
}


void mouseMove(int x, int y) {

	// this will only be true when the left button is down
	if (xOrgin >= 0) {
		deltaAngle = (x + xOrgin) * 0.001f;
		lx = -(angle + deltaAngle);
		lz = (angle- deltaAngle);
	}
	if(xOrgin <= 0) {
		deltaAngle = (x + xOrgin) * 0.001f;
		lx = -(angle + deltaAngle);
		lz = (angle + deltaAngle);
	}
}

void mouseButton(int button, int state, int x, int y) {

	// only start motion if the left button is pressed
	if (button == GLUT_LEFT_BUTTON) {

		// when the button is released
		if (state == GLUT_UP) {
			angle += deltaAngle * 2;
			xOrgin = -1;
		}
		else  {// state = GLUT_DOWN
			xOrgin = -x;
		}
	}

	if(button == GLUT_RIGHT_BUTTON) {
		if(state == GLUT_UP) {
			angle += deltaAngle / 2;
			xOrgin = -1;
		}
		else {
			xOrgin = -x;
		}
	}
}